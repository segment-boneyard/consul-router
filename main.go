package main

import (
	"context"
	"flag"
	"net"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"golang.org/x/crypto/ssh/terminal"

	"github.com/apex/log"
	"github.com/apex/log/handlers/text"

	"github.com/segmentio/ecs-logs-go/apex"
	"github.com/segmentio/ecs-logs-go/log"
	"github.com/segmentio/stats/datadog"
	"github.com/segmentio/stats/httpstats"
	"github.com/segmentio/stats/netstats"
)

func init() {
	if terminal.IsTerminal(1) {
		log.Log = &log.Logger{
			Handler: text.New(os.Stderr),
			Level:   log.DebugLevel,
		}
	} else {
		log.Log = &log.Logger{
			Handler: apex_ecslogs.NewHandler(os.Stderr),
			Level:   log.InfoLevel,
		}
	}
}

func main() {
	var config struct {
		bind    string
		consul  string
		datadog string
		domain  string
		tags    string

		cacheTimeout time.Duration
		dialTimeout  time.Duration
		readTimeout  time.Duration
		writeTimeout time.Duration
		idleTimeout  time.Duration

		cacheSize           int
		maxIdleConns        int
		maxIdleConnsPerHost int
		maxHeaderBytes      int
	}

	flag.StringVar(&config.bind, "bind", ":4000", "The network address on which the router will listen for incoming connections")
	flag.StringVar(&config.consul, "consul", "localhost:8500", "The address at which the router can access a consul agent")
	flag.StringVar(&config.datadog, "datadog", "localhost:8125", "The address at which the router will send datadog metrics")
	flag.StringVar(&config.domain, "domain", "localhost", "The domain for which the router will accept requests")
	flag.StringVar(&config.tags, "tags", "", "A comma-separated list of tags that the router prefers when forwarding requests")
	flag.DurationVar(&config.cacheTimeout, "cache-timeout", 10*time.Second, "The timeout for cached hostnames")
	flag.DurationVar(&config.dialTimeout, "dial-timeout", 10*time.Second, "The timeout for dialing tcp connections")
	flag.DurationVar(&config.readTimeout, "read-timeout", 30*time.Second, "The timeout for reading http requests")
	flag.DurationVar(&config.writeTimeout, "write-timeout", 30*time.Second, "The timeout for writing http requests")
	flag.DurationVar(&config.idleTimeout, "idle-timeout", 90*time.Second, "The timeout for idle connections")
	flag.IntVar(&config.cacheSize, "cache-size", 1000, "The maximum number of cached hostnames")
	flag.IntVar(&config.maxIdleConns, "max-idle-conns", 10000, "The maximum number of idle connections kept")
	flag.IntVar(&config.maxIdleConnsPerHost, "max-idle-conns-per-host", 100, "The maximum number of idle connections kept per host")
	flag.IntVar(&config.maxHeaderBytes, "max-header-bytes", 65536, "The maximum number of bytes allowed in http headers")
	flag.Parse()

	// The datadog client that reports metrics generated by the router.
	dd := datadog.NewClient(datadog.ClientConfig{
		Address: config.datadog,
	})
	defer dd.Close()

	// The consul-based resolver used to lookup services.
	rslv := shuffled(cached(cacheConfig{
		timeout: config.cacheTimeout,
		size:    config.cacheSize,
		rslv:    consulResolver{address: config.consul},
	}))

	// Gracefully shutdown when receiving a signal by closing the datadog client
	// so pending stats are reported before terminating.
	go func() {
		sigchan := make(chan os.Signal)
		signal.Notify(sigchan, syscall.SIGINT, syscall.SIGTERM)
		sig := <-sigchan
		dd.Close()
		os.Exit(int(sig.(syscall.Signal)))
	}()

	// Configure the default http transport which is used for forwarding the requests.
	http.DefaultTransport = httpstats.NewTransport(nil, &http.Transport{
		DialContext:            dialer(config.dialTimeout),
		IdleConnTimeout:        config.idleTimeout,
		MaxIdleConns:           config.maxIdleConns,
		MaxIdleConnsPerHost:    config.maxIdleConnsPerHost,
		ResponseHeaderTimeout:  config.readTimeout,
		ExpectContinueTimeout:  config.readTimeout,
		MaxResponseHeaderBytes: int64(config.maxHeaderBytes),
		DisableCompression:     true,
	})

	// Configure and run the http server.
	if err := (&http.Server{
		Addr: config.bind,

		// These timeout values are here for safety for now, maybe we'll make
		ReadTimeout:    config.readTimeout,
		WriteTimeout:   config.writeTimeout,
		MaxHeaderBytes: config.maxHeaderBytes,
		ErrorLog:       log_ecslogs.New(os.Stderr, "", 0),

		Handler: httpstats.NewHandler(nil, http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
			serveHTTP(res, req, rslv)
		})),
	}).ListenAndServe(); err != nil {
		log.WithError(err).Fatal("failed to serve http requests")
	}
}

func dialer(timeout time.Duration) func(context.Context, string, string) (net.Conn, error) {
	dialer := &net.Dialer{
		Timeout: timeout,
	}
	return func(ctx context.Context, network string, address string) (net.Conn, error) {
		conn, err := dialer.DialContext(ctx, network, address)
		if conn != nil {
			conn = netstats.NewConn(nil, conn)
		}
		return conn, err
	}
}
