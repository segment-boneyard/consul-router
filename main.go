package main

import (
	"context"
	"net"
	"net/http"
	_ "net/http/pprof"
	"os"
	"os/signal"
	"strings"
	"sync/atomic"
	"syscall"
	"time"

	"golang.org/x/crypto/ssh/terminal"

	"github.com/apex/log"
	"github.com/apex/log/handlers/text"

	"github.com/segmentio/conf"
	"github.com/segmentio/ecs-logs-go/apex"
	"github.com/segmentio/stats"
	"github.com/segmentio/stats/datadog"
	"github.com/segmentio/stats/httpstats"
	"github.com/segmentio/stats/netstats"
	"github.com/segmentio/stats/procstats"
)

func init() {
	if terminal.IsTerminal(1) {
		log.Log = &log.Logger{
			Handler: text.New(os.Stderr),
			Level:   log.DebugLevel,
		}
	} else {
		log.Log = &log.Logger{
			Handler: apex_ecslogs.NewHandler(os.Stderr),
			Level:   log.InfoLevel,
		}
	}
}

func main() {
	config := struct {
		BindHTTP        string `conf:"bind-http" help:"The network address on which the router will listen for incoming connections"`
		BindHealthCheck string `conf:"bind-health-check" help:"The network address on which the router listens for health checks"`
		BindPProf       string `conf:"bind-pprof" help:"The network address on which router listens for profiling requests"`
		Consul          string `conf:"consul" help:"The address at which the router can access a consul agent"`
		Datadog         string `conf:"datadog" help:"The address at which the router will send datadog metrics"`
		Domain          string `conf:"domain" help:"The domain for which the router will accept requests"`
		Prefer          string `conf:"prefer" help:"The services with a tag matching the preferred value will be favored by the router"`

		CacheTimeout    time.Duration `conf:"cache-timeout" help:"The timeout for cached hostnames"`
		DialTimeout     time.Duration `conf:"dial-timeout" help:"The timeout for dialing tcp connections"`
		ReadTimeout     time.Duration `conf:"read-timeout" help:"The timeout for reading http requests"`
		WriteTimeout    time.Duration `conf:"write-timeout" help:"The timeout for writing http requests"`
		IdleTimeout     time.Duration `conf:"idle-timeout" help:"The timeout for idle connections"`
		ShutdownTimeout time.Duration `conf:"shutdown-timeout" help:"The timeout for shutting down the router"`

		MaxIdleConns        int  `conf:"max-idle-conns" help:"The maximum number of idle connections kept"`
		MaxIdleConnsPerHost int  `conf:"max-idle-conns-per-host" help:"The maximum number of idle connections kept per host"`
		MaxHeaderBytes      int  `conf:"max-header-bytes" help:"The maximum number of bytes allowed in http headers"`
		EnableCompression   bool `conf:"enable-compression" help:"When set the router will ask for compressed payloads"`
	}{
		CacheTimeout:        10 * time.Second,
		DialTimeout:         10 * time.Second,
		ReadTimeout:         30 * time.Second,
		WriteTimeout:        30 * time.Second,
		IdleTimeout:         90 * time.Second,
		ShutdownTimeout:     10 * time.Second,
		MaxIdleConns:        10000,
		MaxIdleConnsPerHost: 100,
		MaxHeaderBytes:      65536,
	}

	conf.Load(&config)

	// The datadog client that reports metrics generated by the router.
	if len(config.Datadog) != 0 {
		dd := datadog.NewClient(datadog.ClientConfig{
			Address: config.Datadog,
		})
		defer dd.Close()
		log.WithField("address", config.Datadog).Info("using datadog agent for metrics collection")
	}
	defer procstats.StartCollector(procstats.NewGoMetrics(nil)).Close()
	defer procstats.StartCollector(procstats.NewProcMetrics(nil)).Close()

	// Configure the base resolver used by the router to forward requests.
	var rslv resolver
	switch {
	case len(config.Consul) != 0:
		rslv = consulResolver{address: config.Consul}
		log.WithField("address", config.Consul).Info("using consul agent for service discovery")
	default:
		rslv = serviceList(nil)
		log.Warn("no service discovery backend was configured")
	}

	// The domain name served by the router, prefix with '.' so it doesn't have
	// to be done over and over in each http request.
	domain := config.Domain
	if len(domain) != 0 && !strings.HasPrefix(domain, ".") {
		domain = "." + domain
	}

	// Start the health check server, the status variable is used to report when
	// the program is shutting down.
	healthStatus := uint32(http.StatusOK)
	if len(config.BindHealthCheck) != 0 {
		go http.ListenAndServe(config.BindHealthCheck, http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
			res.WriteHeader(int(atomic.LoadUint32(&healthStatus)))
		}))
		log.WithField("address", config.BindHealthCheck).Info("started health check server")
	}

	// Start hte profiler server.
	if len(config.BindPProf) != 0 {
		go http.ListenAndServe(config.BindPProf, nil)
		log.WithField("address", config.BindPProf).Info("started profiling server")
	}

	// Configure the default http transport which is used for forwarding the requests.
	http.DefaultTransport = httpstats.NewTransport(nil, &http.Transport{
		DialContext:            dialer(config.DialTimeout),
		IdleConnTimeout:        config.IdleTimeout,
		MaxIdleConns:           config.MaxIdleConns,
		MaxIdleConnsPerHost:    config.MaxIdleConnsPerHost,
		ResponseHeaderTimeout:  config.ReadTimeout,
		ExpectContinueTimeout:  config.ReadTimeout,
		MaxResponseHeaderBytes: int64(config.MaxHeaderBytes),
		DisableCompression:     !config.EnableCompression,
	})

	// Configure and run the http server.
	var httpLstn net.Listener
	var httpStop chan struct{}
	var httpDone chan struct{}
	var err error

	if len(config.BindHTTP) != 0 {
		if httpLstn, err = net.Listen("tcp", config.BindHTTP); err != nil {
			log.WithFields(log.Fields{
				"address": config.BindHTTP,
				"error":   err,
			}).Fatal("failed to bind tcp address for http server")
		}

		httpLstn = netstats.NewListener(nil, httpLstn, stats.Tag{"side", "frontend"})
		httpStop = make(chan struct{})
		httpDone = make(chan struct{})

		go func() {
			if err := (&http.Server{
				ReadTimeout:    config.ReadTimeout,
				WriteTimeout:   config.WriteTimeout,
				MaxHeaderBytes: config.MaxHeaderBytes,
				Handler: httpstats.NewHandler(nil, newHttpServer(httpServerConfig{
					stop:         httpStop,
					done:         httpDone,
					rslv:         rslv,
					domain:       domain,
					prefer:       config.Prefer,
					cacheTimeout: config.CacheTimeout,
				})),
			}).Serve(httpLstn); err != nil && atomic.LoadUint32(&healthStatus) == http.StatusOK {
				log.WithError(err).Fatal("failed to serve http requests")
			}
		}()

		log.WithField("address", config.BindHTTP).Info("started http server")
	}

	// Gracefully shutdown when receiving a signal:
	// - set the health check status to 503
	// - close tcp connections
	// - wait for in-flight requests to complete
	sigchan := make(chan os.Signal)
	signal.Notify(sigchan, syscall.SIGINT, syscall.SIGTERM)

	sig := <-sigchan
	log.WithField("signal", sig).Info("shutting down")
	atomic.StoreUint32(&healthStatus, http.StatusServiceUnavailable)

	if httpLstn != nil {
		httpLstn.Close()
		close(httpStop)
	}

	for httpDone != nil {
		select {
		case <-time.After(config.ShutdownTimeout):
			return
		case <-sigchan:
			return
		case <-httpDone:
			httpDone = nil
		}
	}
}

func dialer(timeout time.Duration) func(context.Context, string, string) (net.Conn, error) {
	dialer := &net.Dialer{
		Timeout: timeout,
	}
	return func(ctx context.Context, network string, address string) (net.Conn, error) {
		conn, err := dialer.DialContext(ctx, network, address)
		if conn != nil {
			conn = netstats.NewConn(nil, conn, stats.Tag{"side", "backend"})
		}
		return conn, err
	}
}
