package main

import (
	"context"
	"flag"
	"net"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"golang.org/x/crypto/ssh/terminal"

	"github.com/apex/log"
	"github.com/apex/log/handlers/text"

	"github.com/segmentio/ecs-logs-go/apex"
	"github.com/segmentio/stats/datadog"
	"github.com/segmentio/stats/httpstats"
	"github.com/segmentio/stats/netstats"
)

func init() {
	if terminal.IsTerminal(1) {
		log.Log = &log.Logger{
			Handler: text.New(os.Stderr),
			Level:   log.DebugLevel,
		}
	} else {
		log.Log = &log.Logger{
			Handler: apex_ecslogs.NewHandler(os.Stderr),
			Level:   log.InfoLevel,
		}
	}
}

func main() {
	var config struct {
		bind    string
		consul  string
		datadog string
		domain  string
		prefer  string
		health  string

		cacheTimeout time.Duration
		dialTimeout  time.Duration
		readTimeout  time.Duration
		writeTimeout time.Duration
		idleTimeout  time.Duration

		maxIdleConns        int
		maxIdleConnsPerHost int
		maxHeaderBytes      int
	}

	flag.StringVar(&config.bind, "bind", ":4000", "The network address on which the router will listen for incoming connections")
	flag.StringVar(&config.consul, "consul", "localhost:8500", "The address at which the router can access a consul agent")
	flag.StringVar(&config.datadog, "datadog", "localhost:8125", "The address at which the router will send datadog metrics")
	flag.StringVar(&config.domain, "domain", "localhost", "The domain for which the router will accept requests")
	flag.StringVar(&config.prefer, "prefer", "", "The services with a tag matching the preferred value will be favored by the router")
	flag.StringVar(&config.health, "bind-health-check", "", "The network address on which the will listen for health checks")
	flag.DurationVar(&config.cacheTimeout, "cache-timeout", 10*time.Second, "The timeout for cached hostnames")
	flag.DurationVar(&config.dialTimeout, "dial-timeout", 10*time.Second, "The timeout for dialing tcp connections")
	flag.DurationVar(&config.readTimeout, "read-timeout", 30*time.Second, "The timeout for reading http requests")
	flag.DurationVar(&config.writeTimeout, "write-timeout", 30*time.Second, "The timeout for writing http requests")
	flag.DurationVar(&config.idleTimeout, "idle-timeout", 90*time.Second, "The timeout for idle connections")
	flag.IntVar(&config.maxIdleConns, "max-idle-conns", 10000, "The maximum number of idle connections kept")
	flag.IntVar(&config.maxIdleConnsPerHost, "max-idle-conns-per-host", 100, "The maximum number of idle connections kept per host")
	flag.IntVar(&config.maxHeaderBytes, "max-header-bytes", 65536, "The maximum number of bytes allowed in http headers")
	flag.Parse()

	// The datadog client that reports metrics generated by the router.
	dd := datadog.NewClient(datadog.ClientConfig{
		Address: config.datadog,
	})
	defer dd.Close()

	// The consul-based resolver used to lookup services.
	rslv := preferred(config.prefer, shuffled(cached(
		config.cacheTimeout,
		consulResolver{address: config.consul},
	)))

	// The domain name served by the router, prefix with '.' so it doesn't have
	// to be done over and over in each http request.
	domain := config.domain
	if !strings.HasPrefix(domain, ".") {
		domain = "." + domain
	}

	// Gracefully shutdown when receiving a signal by closing the datadog client
	// so pending stats are reported before terminating.
	go func() {
		sigchan := make(chan os.Signal)
		signal.Notify(sigchan, syscall.SIGINT, syscall.SIGTERM)
		sig := <-sigchan
		dd.Close()
		os.Exit(int(sig.(syscall.Signal)))
	}()

	// Start the health check server.
	if len(config.health) != 0 {
		go http.ListenAndServe(config.health, http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
			// TODO: check something?
			res.WriteHeader(http.StatusOK)
		}))
	}

	// Configure the default http transport which is used for forwarding the requests.
	http.DefaultTransport = httpstats.NewTransport(nil, &http.Transport{
		DialContext:            dialer(config.dialTimeout),
		IdleConnTimeout:        config.idleTimeout,
		MaxIdleConns:           config.maxIdleConns,
		MaxIdleConnsPerHost:    config.maxIdleConnsPerHost,
		ResponseHeaderTimeout:  config.readTimeout,
		ExpectContinueTimeout:  config.readTimeout,
		MaxResponseHeaderBytes: int64(config.maxHeaderBytes),
		DisableCompression:     true,
	})

	// Configure and run the http server.
	if err := (&http.Server{
		Addr:           config.bind,
		ReadTimeout:    config.readTimeout,
		WriteTimeout:   config.writeTimeout,
		MaxHeaderBytes: config.maxHeaderBytes,
		Handler:        httpstats.NewHandler(nil, newServer(domain, rslv)),
	}).ListenAndServe(); err != nil {
		log.WithError(err).Fatal("failed to serve http requests")
	}
}

func dialer(timeout time.Duration) func(context.Context, string, string) (net.Conn, error) {
	dialer := &net.Dialer{
		Timeout: timeout,
	}
	return func(ctx context.Context, network string, address string) (net.Conn, error) {
		conn, err := dialer.DialContext(ctx, network, address)
		if conn != nil {
			conn = netstats.NewConn(nil, conn)
		}
		return conn, err
	}
}
